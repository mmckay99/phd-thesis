\subsubsection{Finding a stable \texorpdfstring{$P$}{P}-matching in a triangle-free instance}
\label{sec:threed_sr_as_symmetric_binary_finding_in_triangle_free}

In the previous section, we presented Subroutine~\algorithmfont{repair}, which given a triangle-free instance and a repairable $P$\nobreakdash-matching in that instance, can construct a $P$\nobreakdash-matching in that instance that is stable. In this section we present Subroutine~\algorithmfont{findStableInTriangleFree}, which calls Subroutine~\algorithmfont{repair}. Given a triangle-free instance, Subroutine~\algorithmfont{findStableInTriangleFree} can find a $P$\nobreakdash-matching in that instance that is stable. 

Subroutine~\algorithmfont{findStableInTriangleFree}, shown in Algorithm~\ref{alg:threed_sr_as_find_stable_pmatching_in_triangle_free_instance}, is recursive. The subroutine first constructs a smaller instance $(N', V')$ from $(N, V)$ by removing an arbitrary agent $\alpha_i$. It then uses a recursive call to construct a $P$\nobreakdash-matching $M$ that is stable in the smaller instance $(N', V')$. By Proposition~\ref{prop:threed_sr_as_blockerimprovement}, any triple that blocks $M$ in the larger instance $(N, V)$ must either contain $\alpha_i$ or also block $M$ in the smaller instance $(N', V')$. There are three possible cases involving types of triple that block $M$ in $(N', V')$. In two out of three cases, the subroutine constructs $M'$ in a straightforward way by adding to $M$ a new triple that contains $\alpha_i$ and two agents that are unmatched in $M$. In the third case, $M$ must be repairable. It follows by Lemma~\ref{lem:threed_sr_as_symmetric_binary_algoreturnsstablematching} that Subroutine~\algorithmfont{repair} can be used to construct a $P$\nobreakdash-matching that is stable in $(N, V)$.

\input{algorithms/threed_sr_as/find_stable_pmatching_triangle_free}

In the following lemma we verify the correctness of Subroutine~\algorithmfont{findStableInTriangleFree}.

\begin{lem}
\label{lem:threed_sr_as_symmetric_binary_algfindsstablepmatching_notimecomplex}
Given a triangle-free instance $(N, V)$, Subroutine~\algorithmfont{findStableInTriangleFree} returns a stable $P$\nobreakdash-matching in $(N, V)$.
\end{lem}
\begin{proof}
By strong induction on $|N|$. In the base case, suppose $|N| \leq 2$. It follows by the pseudocode that the subroutine returns $\varnothing$, which is a stable $P$\nobreakdash-matching in $(N, V)$.

We now show the inductive step. Consider the execution of the subroutine given some an arbitrary instance $(N, V)$. By the inductive hypothesis it follows that the subroutine returns a stable $P$\nobreakdash-matching $M$ in the smaller instance $(N', V')$, since $|N'| < |N|$.

Consider the first branch of the if/else statement in Subroutine~\algorithmfont{findStableInTriangleFree}. By construction, $u_{\alpha_{i}}(M') = 2$ and $u_{\alpha_{l_1}}(M')=u_{\alpha_{l_2}}(M')=1$. Since $M$ is a $P$\nobreakdash-matching, it follows that the subroutine returns some $P$\nobreakdash-matching $M'$. Since $u_{\alpha_i}(M')=2$, no triple that contains $\alpha_i$ blocks $M'$ in $(N, V)$. By construction, $u_{\alpha_p}(M')\geq u_{\alpha_p}(M)$ for any $\alpha_p \in N$, so it follows that any triple that blocks $M'$ in $(N, V)$ also blocks $M$ in $(N', V')$. It follows that $M'$ is stable in $(N, V)$.

Consider the second branch of the if/else statement. By construction, $u_{\alpha_{l_3}}(M')=2$ and $u_{\alpha_{i}}(M')=u_{\alpha_{l_3}}(M')=1$. Since $M$ is a $P$\nobreakdash-matching, it follows that the subroutine returns some $P$\nobreakdash-matching $M'$. Suppose for a contradiction that some triple blocks $M'$ in $(N, V)$. By construction, $u_{\alpha_p}(M')\geq u_{\alpha_p}(M)$ for any $\alpha_p\in N$ so any triple that blocks $M'$ in $(N, V)$ must contain $\alpha_i$, for otherwise that triple blocks $M$ in $(N', V')$, which is a contradiction. Suppose then that some triple $\{ \alpha_i, \alpha_{k_1}, \alpha_{k_2} \}$ blocks $M'$ in $(N, V)$, where $\alpha_{k_1}, \alpha_{k_2} \in N'$. By construction, $u_{\alpha_i}(M')=1$ so it must be that $u_{\alpha_i}(\{ \alpha_{k_1}, \alpha_{k_2} \})=2$ and thus that $v_{\alpha_i}(\alpha_{k_1})=v_{\alpha_i}(\alpha_{k_2})=1$. Since $(N, V)$ is triangle-free, it follows that $v_{\alpha_{k_1}}(\alpha_{k_2}) = 0$ and thus that $u_{\alpha_{k_1}}(\{ \alpha_{i}, \alpha_{k_2} \})=u_{\alpha_{k_2}}(\{ \alpha_{i}, \alpha_{k_1} \})=1$. It then follows that $u_{\alpha_{k_1}}(M')=u_{\alpha_{k_2}}(M')=0$. By the construction of $M'$ it must be that $u_{\alpha_p}(M')\geq u_{\alpha_p}(M)$ for any $\alpha_p\in N$ so $u_{\alpha_{k_1}}(M)=u_{\alpha_{k_2}}(M)=0$. This contradicts the condition of the first branch of the if/else statement, since there exist two agents $\alpha_{l_1}$ and $\alpha_{l_2}$, namely $\alpha_{k_1}$, and $\alpha_{k_2}$, where $u_{\alpha_{l_1}}(M)=u_{\alpha_{l_2}}(M)=0$ and $v_{\alpha_i}(\alpha_{l_1})=v_{\alpha_i}(\alpha_{l_2})=1$.

Consider the third branch of the if/else statement. It must be that the conditional expressions in the first and second branches of the if/else statement do not hold. It follows from this that any triple that blocks $M$ in $(N', V')$ comprises $\{ \alpha_i, \alpha_{l_5}, \alpha_{l_6} \}$ where $\alpha_{l_5}, \alpha_{l_6}\in N$, $u_{\alpha_{l_5}}(M)=1$, $u_{\alpha_{l_6}}(M)=0$, and $v_{\alpha_i}(\alpha_{l_5})=v_{\alpha_{l_5}}(\alpha_{l_6})=1$. Note that $u_{\alpha_i}(M)=0$ and thus $M$ is repairable (defined in Section~\ref{sec:threed_sr_as_symmetric_binary_repairing}). By Lemma~\ref{lem:threed_sr_as_symmetric_binary_algoreturnsstablematching}, Subroutine~ \algorithmfont{repair} returns some $P$\nobreakdash-matching $M'$ that is stable in $(N, V)$.

Consider the fourth branch of the if/else statement. It must be that the conditional expressions in the first, second, and third branches of the if/else statement do not hold. By construction, $u_{\alpha_p}(M') = u_{\alpha_p}(M)$ for any $\alpha_p\in N$. It follows that any triple that blocks $M'$ in $(N, V)$ must contain $\alpha_i$, for otherwise that triple also blocks $M$ in $(N', V')$, which is a contradiction. Suppose for a contradiction that some triple $\{ \alpha_i, \alpha_{k_1}, \alpha_{k_2} \}$ blocks $M'$ in $(N, V)$.

Suppose firstly that $u_{\alpha_i}(\{ \alpha_{k_1}, \alpha_{k_2} \})=2$. Since $(N, V)$ is triangle-free, it follows that $u_{\alpha_{k_1}}(\{ \alpha_{i}, \alpha_{k_2} \})=u_{\alpha_{k_2}}(\{ \alpha_{i}, \alpha_{k_1} \})=1$. It follows that $u_{\alpha_{k_1}}(M')=u_{\alpha_{k_2}}(M')=0$. Since $u_{\alpha_p}(M')\geq u_{\alpha_p}(M)$ for any $\alpha_p\in N$, it must be that $u_{\alpha_{k_1}}(M)=u_{\alpha_{k_2}}(M)=0$. This contradicts the condition of the first branch of the if/else statement.

Suppose secondly that $u_{\alpha_i}(\{ \alpha_{k_1}, \alpha_{k_2} \})=1$. It must be that either $u_{\alpha_{k_1}}(\{ \alpha_{i}, \alpha_{k_2} \})=2$ or $u_{\alpha_{k_2}}(\{ \alpha_{i}, \alpha_{k_1} \})=2$. Suppose without loss of generality that $u_{\alpha_{k_1}}(\{ \alpha_{i}, \alpha_{k_2} \})=2$. It follows that $v_{\alpha_{k_1}}(\alpha_{i})=v_{\alpha_{k_1}}(\alpha_{k_2})=1$. There are two possibilities: either $u_{\alpha_{k_1}}(M)=1$ or $u_{\alpha_{k_1}}(M)=0$. The first possibility implies that the conditional expression of the second if/else branch holds, which is a contradiction. The second possibility implies that the conditional expression of the third if/else branch holds, also a contradiction.
\end{proof}

We now consider the worst-case time complexity of Subroutine~\algorithmfont{findStableInTriangleFree}.

\begin{lem}
\label{lem:threed_sr_as_symmetric_binary_algfindstablepmatchingrunningtime}
Subroutine~\algorithmfont{findStableInTriangleFree} has running time $O(|N|^3)$.
\end{lem}
\begin{proof}
% The pseudocode for Subroutine~\algorithmfont{findStableInTriangleFree} gives an outline of the subroutine at a high level. As before, to analyse the worst-case time complexity we provide a more detailed description of certain steps in terms of the unit cost of operations in standard data structures. This description suffices to show that the running time of the subroutine is $O(|N|^3)$. 
% Let $T(|N|)$ be the running time of the subroutine given an instance $(N, V)$. We will prove inductively that $T(|N|)=O(|N|^3)$.

Since Subroutine~\algorithmfont{findStableInTriangleFree} is recursive, and the recursive call involves an instance $(N', V')$ where $|N'| = |N| - 1$, it suffices to show that worst-case time complexity of the subroutine excluding the recursive call is $O(|N|^2)$.

Suppose that the input $(N, V)$ is given such that, for a given $\alpha_{p}\in N$, the subroutine can iterate through the set $\{ \alpha_{q} \in N : v_{\alpha_{p}}(\alpha_{q})=1 \}$ in $O(|N|)$ time. For example, $(N, V)$ could be stored as a graph using adjacency lists. It follows that, given three agents $\alpha_{h_1}, \alpha_{h_2}, \alpha_{h_3}\in N$ the subroutine can compute $u_{\alpha_{h_1}}(\{ \alpha_{h_2}, \alpha_{h_3} \})$, $u_{\alpha_{h_2}}(\{ \alpha_{h_1}, \alpha_{h_3} \})$ and $u_{\alpha_{h_3}}(\{ \alpha_{h_1}, \alpha_{h_2} \})$ in $O(|N|)$ time. The subroutine will return a $P$\nobreakdash-matching $M'$ stored as a linked list or similar data structure that allows a triple to be appended to the end of list in constant time.

% By inspection, when $|N|=2$ the subroutine returns immediately and hence $T(2)=O(1)$. In this case the subroutine will return an empty linked list or similar data structure.

The constructed instance $(N',V')$ can be stored using adjacency lists or an equivalent data structure. A straightforward procedure to identify $\alpha_i$ and construct $(N', V')$ takes $O(|N|)$ time.

After this call, the subroutine can construct a supplementary lookup table $L_1$, with exactly $|N|-1$ entries indexed by each $\alpha_p\in N'$. Each entry will contain either zero, one, or two. For each agent $\alpha_p\in N$, the subroutine constructs $L_1$ so that the $p\textsuperscript{th}$ entry contains $u_{\alpha_p}(M)$. By assumption, the subroutine can compute $u_{\alpha_p}(M)$ for any $\alpha_p\in N$ in $O(|N|)$ time. It follows that $L_1$ can be constructed in $O(|N|^2)$ time by iterating through $M$ and computing $u_{\alpha_{h_1}}(M)$, $u_{\alpha_{h_2}}(M)$, and $u_{\alpha_{h_3}}(M)$ for each triple $\{ \alpha_{h_1}, \alpha_{h_2}, \alpha_{h_3} \} \in M$. Since $|M|=O(|N|)$ this step takes $O(|N|^2)$ time. It follows that we can use $L_1$ to look up $u_{\alpha_{p}}(M)$ for any $\alpha_{p}\in N$ in constant time.

The construction of $L_1$ allows the subroutine to identify some $\alpha_{l_1}$ and $\alpha_{l_2}\in N$ where $u_{\alpha_{l_1}}(M)=u_{\alpha_{l_2}}(M)=0$ and $v_{\alpha_i}(\alpha_{l_1})=v_{\alpha_i}(\alpha_{l_2})=1$, if two such agents exist, in $O(|N|^2)$ time. One way to do this is to consider each pair $\{ \alpha_{l_1}, \alpha_{l_2} \} \in \binom{N}{2}$ and look up $u_{\alpha_{l_1}}(M)$ and $u_{\alpha_{l_2}}(M)$ in $L_1$. Since $M$ is stored using a linked list or similar data structure, if such $\alpha_{l_1}, \alpha_{l_2}\in N$ exist then $M'$ can be constructed by adding the triple $\{ \alpha_i, \alpha_{l_1}, \alpha_{l_2} \}$ to $M$, in constant time. Similarly, the identification of $\alpha_{l_3}, \alpha_{l_4}\in N$ where $u_{\alpha_{l_3}}(M)=u_{\alpha_{l_4}}(M)=0$ and $v_{\alpha_i}(\alpha_{l_3})=v_{\alpha_{l_3}}(\alpha_{l_4})=1$ can be performed in $O(|N|^2)$ time and the corresponding construction of $M'$ in constant time. In the third branch of the if/else statement, the identification of $\alpha_{l_5}, \alpha_{l_6}\in N$ where $u_{\alpha_{l_3}}(M)=1$, $u_{\alpha_{l_4}}(M)=0$ and $v_{\alpha_i}(\alpha_{l_3})=v_{\alpha_{l_3}}(\alpha_{l_4})=1$ can be similarly performed in $O(|N|^2)$ time. By Lemma~\ref{lem:threed_sr_as_symmetric_binary_almosttherealgo_runningtime}, the call to Subroutine~\algorithmfont{repair} also takes $O(|N|^2)$ time.
\end{proof}